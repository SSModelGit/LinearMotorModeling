package Modelica "Modelica Standard Library (Version 3.1)"
  annotation(Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10}), graphics={Rectangle(visible=true, lineColor={64,64,64}, fillPattern=FillPattern.Solid, lineThickness=4, extent={{-90.0,-90.0},{90.0,90.0}}, radius=25),Polygon(visible=true, origin={79.8711,-34.462}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-10.683,-4.829},{10.087,-24.805},{10.087,5.49},{-9.492,24.143}}),Polygon(visible=true, origin={56.257,-26.9544}, fillColor={181,159,75}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-13.262,-16.834},{12.799,-12.336},{13.99,16.768},{-13.527,12.402}}),Polygon(visible=true, origin={39.4891,-40.9112}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-4.167,3.473},{-2.58,-27.087},{3.506,-2.877},{3.241,26.491}}),Polygon(visible=true, origin={22.6219,-52.1229}, fillColor={181,159,75}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-15.081,16.272},{-12.039,-14.949},{14.287,-15.875},{12.832,14.552}}),Polygon(visible=true, origin={-1.614,-25.0031}, fillColor={181,159,75}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-14.922,22.225},{-12.144,-7.408},{9.816,-17.198},{9.155,-10.98},{8.096,13.361}}),Polygon(visible=true, origin={-27.2208,-25.3982}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{10.817,22.62},{13.463,-7.013},{-9.891,-22.818},{-14.389,7.212}}),Polygon(visible=true, origin={-48.5841,-25.8961}, fillColor={181,159,75}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-12.138,23.647},{-6.185,-9.161},{11.41,-22.258},{6.912,7.772}}),Polygon(visible=true, origin={-61.3304,14.949}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-18.706,15.214},{-12.488,-15.875},{2.461,-15.743},{19.394,0.132},{9.34,16.272}}),Polygon(visible=true, origin={-61.0526,64.856}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-9.591,16.503},{-5.226,-12.865},{4.564,-10.22},{10.253,6.582}}),Polygon(visible=true, origin={13.81,38.19}, lineColor={255,255,255}, fillColor={255,228,105}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, lineThickness=1, points={{-77.467,51.81},{-84.478,43.013},{-64.635,33.223},{-70.455,16.554},{-95.855,8.617},{-93.739,-8.052},{-65.958,-6.994},{-55.903,-23.133},{-74.424,-40.596},{-55.374,-56.471},{-30.239,-41.125},{-7.485,-49.856},{-6.162,-74.198},{21.62,-75.785},{28.763,-52.767},{56.28,-48.533},{76.124,-67.319},{76.19,28.196},{75.859,33.554},{74.272,38.515},{72.023,42.417},{68.98,45.923},{65.21,48.701},{60.778,50.752},{55.618,51.744},{50.459,51.81}}),Polygon(visible=true, origin={27.0193,48.4073}, lineColor={255,255,255}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, lineThickness=1, points={{-48.98,41.683},{-48.98,41.593},{-57.446,33.878},{-64.061,25.808},{-68.956,15.225},{-70.411,4.642},{-69.22,-5.677},{-65.781,-14.408},{-60.886,-22.081},{-54.933,-28.828},{-45.672,-35.31},{-31.782,-42.719},{-15.775,-48.01},{2.614,-50.392},{20.209,-49.73},{36.613,-46.687},{51.43,-41.925},{62.939,-34.781},{62.981,-34.781},{62.935,17.941},{62.605,23.298},{61.017,28.259},{58.768,32.162},{55.725,35.668},{51.955,38.446},{47.523,40.496},{42.364,41.489},{37.205,41.555}}, smooth=Smooth.Bezier),Polygon(visible=true, origin={31.0951,49.0533}, fillColor={212,177,67}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, points={{-27.788,41.037},{-27.788,40.947},{-40.62,33.497},{-50.41,25.956},{-58.347,16.96},{-63.639,7.568},{-66.417,-2.354},{-66.285,-12.541},{-63.374,-21.272},{-57.818,-28.813},{-49.553,-35.887},{-35.663,-43.295},{-19.655,-48.587},{-1.267,-50.968},{16.328,-50.306},{32.732,-47.264},{47.549,-42.501},{59.058,-35.357},{59.058,-35.357},{59.054,17.364},{58.724,22.722},{57.136,27.683},{54.887,31.586},{51.845,35.091},{48.074,37.87},{43.642,39.92},{38.483,40.912},{33.324,40.978}}, smooth=Smooth.Bezier),Ellipse(visible=true, origin={36.4427,46.5703}, lineColor={110,97,47}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, lineThickness=1, extent={{-39.026,-27.4505},{39.026,27.4505}}),Ellipse(visible=true, origin={36.1156,56.0255}, lineColor={255,255,255}, fillColor={255,228,105}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, lineThickness=1, extent={{-39.026,-27.4505},{39.026,27.4505}}),Ellipse(visible=true, origin={35.9797,56.5751}, fillColor={110,97,47}, pattern=LinePattern.None, fillPattern=FillPattern.Solid, extent={{-26.5943,-18.7061},{26.5943,18.7061}}),Rectangle(visible=true, lineColor={64,64,64}, lineThickness=4, extent={{-90.0,-90.0},{90.0,90.0}}, radius=25)}), preferredView="info", version="3.1", versionBuild=5, versionDate="2009-08-14", dateModified="2009-12-18 08:49:49Z", revisionId="$Id:: package.mo 3222 2009-12-18 08:53:50Z #$", conversion(noneFromVersion="3.0.1", noneFromVersion="3.0", from(version="2.1", script="Scripts/ConvertModelica_from_2.2.2_to_3.0.mos"), from(version="2.2", script="Scripts/ConvertModelica_from_2.2.2_to_3.0.mos"), from(version="2.2.1", script="Scripts/ConvertModelica_from_2.2.2_to_3.0.mos"), from(version="2.2.2", script="Scripts/ConvertModelica_from_2.2.2_to_3.0.mos")), __Dymola_classOrder={"UsersGuide","Blocks","StateGraph","Electrical","Magnetic","Mechanics","Fluid","Media","Thermal","Math","Utilities","Constants","Icons","SIunits"}, Settings(NewStateSelection=true), Documentation(info="<HTML>
<p>
Package <b>Modelica</b> is a <b>standardized</b> and <b>free</b> package
that is developed together with the Modelica language from the
Modelica Association, see
<a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
It is also called <b>Modelica Standard Library</b>.
It provides model components in many domains that are based on
standardized interface definitions. Some typical examples are shown
in the next figure:
</p>

<p>
<img src=\"Images/UsersGuide/ModelicaLibraries.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"Modelica://Modelica.UsersGuide.Overview\">Overview</a>
  provides an overview of the Modelica Standard Library
  inside the <a href=\"Modelica://Modelica.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
 summarizes the changes of new versions of this package.</li>
<li> <a href=\"Modelica://Modelica.UsersGuide.Contact\">Contact</a>
  lists the contributors of the Modelica Standard Library.</li>
<li> The <b>Examples</b> packages in the various libraries, demonstrate
  how to use the components of the corresponding sublibrary.</li>
</ul>

<p>
This version of the Modelica Standard Library consists of
</p>
<ul>
<li> <b>922</b> models and blocks, and</li>
<li> <b>615</b> functions
</ul>
<p>
that are directly usable (= number of public, non-partial classes).
</p>


<p>
<b>Licensed by the Modelica Association under the Modelica License 2</b><br>
Copyright &copy; 1998-2009, ABB, arsenal research, T.&nbsp;Bödrich, DLR, Dynasim, Fraunhofer, Modelon,
TU Hamburg-Harburg, Politecnico di Milano.
</p>

<p>
<i>This Modelica package is <u>free</u> software and
the use is completely at <u>your own risk</u>;
it can be redistributed and/or modified under the terms of the
Modelica license 2, see the license conditions (including the
disclaimer of warranty)
<a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">here</a></u>
or at
<a href=\"http://www.Modelica.org/licenses/ModelicaLicense2\">
http://www.Modelica.org/licenses/ModelicaLicense2</a>.
</p>

</HTML>
"));
  package Mechanics "Library of 1-dim. and 3-dim. mechanical components (multi-body, rotational, translational)"
    extends Modelica.Icons.Library;
    annotation(Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10}), graphics={Rectangle(visible=true, origin={9.0,46.0}, fillColor={192,192,192}, fillPattern=FillPattern.HorizontalCylinder, extent={{-5.0,-70.0},{45.0,-40.0}}),Ellipse(visible=true, origin={9.0,46.0}, extent={{-90.0,-60.0},{-80.0,-50.0}}),Line(visible=true, origin={9.0,46.0}, points={{-85.0,-55.0},{-60.0,-21.0}}, thickness=0.5),Ellipse(visible=true, origin={9.0,46.0}, extent={{-65.0,-26.0},{-55.0,-16.0}}),Line(visible=true, origin={9.0,46.0}, points={{-60.0,-21.0},{9.0,-55.0}}, thickness=0.5),Ellipse(visible=true, origin={9.0,46.0}, fillPattern=FillPattern.Solid, extent={{4.0,-60.0},{14.0,-50.0}}),Line(visible=true, origin={9.0,46.0}, points={{-10.0,-34.0},{72.0,-34.0},{72.0,-76.0},{-10.0,-76.0}})}), Documentation(info="<HTML>
<p>
This package contains components to model the movement
of 1-dim. rotational, 1-dim. translational, and
3-dim. <b>mechanical systems</b>.
</p>
</HTML>
"));
    package Translational "Library to model 1-dimensional, translational mechanical systems"
      extends Modelica.Icons.Library;
      import SI = Modelica.SIunits;
      package Interfaces "Interfaces for 1-dim. translational mechanical components"
        extends Modelica.Icons.Library;
        connector Flange_a "(left) 1D translational flange (flange axis directed INTO cut plane, e. g. from left to right)"
          SI.Position s "absolute position of flange";
          flow SI.Force f "cut force directed into flange";
          annotation(defaultComponentName="flange_a", Documentation(info="<html>
This is a flange for 1D translational mechanical systems. In the cut plane of
the flange a unit vector n, called flange axis, is defined which is directed
INTO the cut plane, i. e. from left to right. All vectors in the cut plane are
resolved with respect to
this unit vector. E.g. force f characterizes a vector which is directed in
the direction of n with value equal to f. When this flange is connected to
other 1D translational flanges, this means that the axes vectors of the connected
flanges are identical.
</p>
<p>
The following variables are transported through this connector:
<pre>
  s: Absolute position of the flange in [m]. A positive translation
     means that the flange is translated along the flange axis.
  f: Cut-force in direction of the flange axis in [N].
</pre>
</HTML>
"), Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={Rectangle(extent={{-100,-100},{100,100}}, lineColor={0,127,0}, fillColor={0,127,0}, fillPattern=FillPattern.Solid)}), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={Rectangle(extent={{-40,-40},{40,40}}, lineColor={0,127,0}, fillColor={0,127,0}, fillPattern=FillPattern.Solid),Text(extent={{-160,110},{40,50}}, lineColor={0,127,0}, textString="%name")}));
        end Flange_a;

        annotation(Documentation(info="<html>
<p>
This package contains connectors and partial models for 1-dim.
translational mechanical components. The components of this package can
only be used as basic building elements for models.
</p>

</html>
"));
      end Interfaces;

      annotation(Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10}), graphics={Line(visible=true, origin={9.0,57.5}, points={{-84.0,-73.0},{66.0,-73.0}}),Rectangle(visible=true, origin={9.0,57.5}, fillColor={192,192,192}, fillPattern=FillPattern.Sphere, extent={{-81.0,-65.0},{-8.0,-22.0}}),Line(visible=true, origin={9.0,57.5}, points={{-8.0,-43.0},{-1.0,-43.0},{6.0,-64.0},{17.0,-23.0},{29.0,-65.0},{40.0,-23.0},{50.0,-44.0},{61.0,-44.0}}),Line(visible=true, origin={9.0,57.5}, points={{-59.0,-73.0},{-84.0,-93.0}}),Line(visible=true, origin={9.0,57.5}, points={{-11.0,-73.0},{-36.0,-93.0}}),Line(visible=true, origin={9.0,57.5}, points={{-34.0,-73.0},{-59.0,-93.0}}),Line(visible=true, origin={9.0,57.5}, points={{14.0,-73.0},{-11.0,-93.0}}),Line(visible=true, origin={9.0,57.5}, points={{39.0,-73.0},{14.0,-93.0}}),Line(visible=true, origin={9.0,57.5}, points={{63.0,-73.0},{38.0,-93.0}})}), Documentation(info="<html>
<p>
This package contains components to model <i>1-dimensional translational
mechanical</i> systems.
</p>
<p>
The <i>filled</i> and <i>non-filled green squares</i> at the left and
right side of a component represent <i>mechanical flanges</i>.
Drawing a line between such squares means that the corresponding
flanges are <i>rigidly attached</i> to each other. The components of this
library can be usually connected together in an arbitrary way. E.g. it is
possible to connect two springs or two sliding masses with inertia directly
together.
<p> The only <i>connection restriction</i> is that the Coulomb friction
elements (e.g. MassWithStopAndFriction) should be only connected
together provided a compliant element, such as a spring, is in between.
The reason is that otherwise the frictional force is not uniquely
defined if the elements are stuck at the same time instant (i.e., there
does not exist a unique solution) and some simulation systems may not be
able to handle this situation, since this leads to a singularity during
simulation. It can only be resolved in a \"clean way\" by combining the
two connected friction elements into
one component and resolving the ambiguity of the frictional force in the
stuck mode.
</p>
<p> Another restriction arises if the hard stops in model MassWithStopAndFriction are used, i. e.
the movement of the mass is limited by a stop at smax or smin.
<font color=\"#ff0000\"> <b>This requires the states Stop.s and Stop.v</b> </font>. If these states are eliminated during the index reduction
the model will not work. To avoid this any inertias should be connected via springs
to the Stop element, other sliding masses, dampers or hydraulic chambers must be avoided. </p>
<p>
In the <i>icon</i> of every component an <i>arrow</i> is displayed in grey
color. This arrow characterizes the coordinate system in which the vectors
of the component are resolved. It is directed into the positive
translational direction (in the mathematical sense).
In the flanges of a component, a coordinate system is rigidly attached
to the flange. It is called <i>flange frame</i> and is directed in parallel
to the component coordinate system. As a result, e.g., the positive
cut-force of a \"left\" flange (flange_a) is directed into the flange, whereas
the positive cut-force of a \"right\" flange (flange_b) is directed out of the
flange. A flange is described by a Modelica connector containing
the following variables:
</p>
<pre>
   Modelica.SIunits.Position s    \"Absolute position of flange\";
   <b>flow</b> Modelica.SIunits.Force f  \"Cut-force in the flange\";
</pre>

<p>
This library is designed in a fully object oriented way in order that
components can be connected together in every meaningful combination
(e.g. direct connection of two springs or two shafts with inertia).
As a consequence, most models lead to a system of
differential-algebraic equations of <i>index 3</i> (= constraint
equations have to be differentiated twice in order to arrive at
a state space representation) and the Modelica translator or
the simulator has to cope with this system representation.
According to our present knowledge, this requires that the
Modelica translator is able to symbolically differentiate equations
(otherwise it is e.g. not possible to provide consistent initial
conditions; even if consistent initial conditions are present, most
numerical DAE integrators can cope at most with index 2 DAEs).
</p>

<dl>
<dt><b>Library Officer</b>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> <br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik (DLR-RM)<br>
    Abteilung Systemdynamik und Regelungstechnik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br><br>
</dl>

<p>
<b>Contributors to this library:</b>
</p>

<ul>
<li> Main author until 2006:<br>
     Peter Beater <br>
     Universit&auml;t Paderborn, Abteilung Soest<br>
     Fachbereich Maschinenbau/Automatisierungstechnik<br>
     L&uuml;becker Ring 2 <br>
     D 59494 Soest <br>
     Germany <br>
     email: <A HREF=\"mailto:info@beater.de\">info@beater.de</A><br><br>
     </li>

<li> <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
     Technical Consulting &amp; Electrical Engineering<br>
     A-3423 St.Andrae-Woerdern, Austria<br>
     email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a><br><br></li>

<li> <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> (DLR-RM)</li>
</ul>

<p>
Copyright &copy; 1998-2009, Modelica Association, Anton Haumer and Universit&auml;t Paderborn, FB 12.
</p>
<p>
<i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b>
<a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">here</a>.</i>
</p><br>

</HTML>
", revisions="<html>
<ul>
<li><i>Version 1.0 (January 5, 2000)</i>
       by Peter Beater <br>
       Realized a first version based on Modelica library Mechanics.Rotational
       by Martin Otter and an existing Dymola library onedof.lib by Peter Beater.
       <br>
<li><i>Version 1.01 (July 18, 2001)</i>
       by Peter Beater <br>
       Assert statement added to \"Stop\", small bug fixes in examples.
       <br>
</li>
<li><i>Version 1.1.0 2007-11-16</i>
       by Anton Haumer<br>
       Redesign for Modelica 3.0-compliance<br>
       Added new components acording to Mechanics.Rotational library
       <br>
</li>
</ul>
</html>"));
    end Translational;

  end Mechanics;

  package Math "Library of mathematical functions (e.g., sin, cos) and of functions operating on vectors and matrices"
    extends Modelica.Icons.Library;
    import SI = Modelica.SIunits;
    function sin "Sine"
      extends baseIcon1;
      input SI.Angle u;
      output Real y;

      external "C" y=sin(u) ;
      annotation(Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={2,2}), graphics={Line(points={{-90,0},{68,0}}, color={192,192,192}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}}, lineColor={192,192,192}, fillColor={192,192,192}, fillPattern=FillPattern.Solid),Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={0,0,0}),Text(extent={{12,84},{84,36}}, lineColor={192,192,192}, textString="sin")}), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={2,2}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),Polygon(points={{100,0},{84,6},{84,-6},{100,0}}, lineColor={95,95,95}, fillColor={95,95,95}, fillPattern=FillPattern.Solid),Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={0,0,255}, thickness=0.5),Text(extent={{-105,72},{-85,88}}, textString="1", lineColor={0,0,255}),Text(extent={{70,25},{90,5}}, textString="2*pi", lineColor={0,0,255}),Text(extent={{-103,-72},{-83,-88}}, textString="-1", lineColor={0,0,255}),Text(extent={{82,-6},{102,-26}}, lineColor={95,95,95}, textString="u"),Line(points={{-80,80},{-28,80}}, color={175,175,175}, smooth=Smooth.None),Line(points={{-80,-80},{50,-80}}, color={175,175,175}, smooth=Smooth.None)}), Documentation(info="<html>
<p>
This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"../Images/Math/sin.png\">
</p>
</html>"), Library="ModelicaExternalC");
    end sin;

    function cos "Cosine"
      extends baseIcon1;
      input SI.Angle u;
      output Real y;

      external "C" y=cos(u) ;
      annotation(Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={2,2}), graphics={Line(points={{-90,0},{68,0}}, color={192,192,192}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}}, lineColor={192,192,192}, fillColor={192,192,192}, fillPattern=FillPattern.Solid),Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},{-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},{-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},{24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,73.4},{75.2,78.6},{80,80}}, color={0,0,0}),Text(extent={{-36,82},{36,34}}, lineColor={192,192,192}, textString="cos")}), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={2,2}), graphics={Text(extent={{-103,72},{-83,88}}, textString="1", lineColor={0,0,255}),Text(extent={{-103,-72},{-83,-88}}, textString="-1", lineColor={0,0,255}),Text(extent={{70,25},{90,5}}, textString="2*pi", lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),Polygon(points={{98,0},{82,6},{82,-6},{98,0}}, lineColor={95,95,95}, fillColor={95,95,95}, fillPattern=FillPattern.Solid),Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},{-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},{-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},{24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,73.4},{75.2,78.6},{80,80}}, color={0,0,255}, thickness=0.5),Text(extent={{78,-6},{98,-26}}, lineColor={95,95,95}, textString="u"),Line(points={{-80,-80},{18,-80}}, color={175,175,175}, smooth=Smooth.None)}), Documentation(info="<html>
<p>
This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"../Images/Math/cos.png\">
</p>
</html>"), Library="ModelicaExternalC");
    end cos;

    function atan "Inverse tangent"
      extends baseIcon2;
      input Real u;
      output SI.Angle y;

      external "C" y=atan(u) ;
      annotation(Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Line(points={{-90,0},{68,0}}, color={192,192,192}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}}, lineColor={192,192,192}, fillColor={192,192,192}, fillPattern=FillPattern.Solid),Line(points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},{-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},{9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},{69.5,78.6},{80,80}}, color={0,0,0}),Text(extent={{-86,68},{-14,20}}, lineColor={192,192,192}, textString="atan")}), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),Polygon(points={{96,0},{80,6},{80,-6},{96,0}}, lineColor={95,95,95}, fillColor={95,95,95}, fillPattern=FillPattern.Solid),Line(points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},{-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},{9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},{65,77},{80,78}}, color={0,0,255}, thickness=0.5),Text(extent={{-34,87},{-14,74}}, textString="pi/2", lineColor={0,0,255}),Text(extent={{-32,-71},{-12,-91}}, textString="-pi/2", lineColor={0,0,255}),Text(extent={{84,-4},{104,-24}}, lineColor={95,95,95}, textString="u"),Line(points={{-2,80},{84,80}}, color={175,175,175}, smooth=Smooth.None)}), Documentation(info="<html>
<p>
This function returns y = atan(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"../Images/Math/atan.png\">
</p>
</html>"), Library="ModelicaExternalC");
    end atan;

    partial function baseIcon1 "Basic icon for mathematical function with y-axis on left side"
      annotation(Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0}, fillColor={255,255,255}, fillPattern=FillPattern.Solid),Line(points={{-80,-80},{-80,68}}, color={192,192,192}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}}, lineColor={192,192,192}, fillColor={192,192,192}, fillPattern=FillPattern.Solid),Text(extent={{-150,150},{150,110}}, textString="%name", lineColor={0,0,255})}), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={Line(points={{-80,80},{-88,80}}, color={95,95,95}),Line(points={{-80,-80},{-88,-80}}, color={95,95,95}),Line(points={{-80,-90},{-80,84}}, color={95,95,95}),Text(extent={{-75,104},{-55,84}}, lineColor={95,95,95}, textString="y"),Polygon(points={{-80,98},{-86,82},{-74,82},{-80,98}}, lineColor={95,95,95}, fillColor={95,95,95}, fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis on the left side.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end baseIcon1;

    partial function baseIcon2 "Basic icon for mathematical function with y-axis in middle"
      annotation(Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}}, lineColor={0,0,0}, fillColor={255,255,255}, fillPattern=FillPattern.Solid),Line(points={{0,-80},{0,68}}, color={192,192,192}),Polygon(points={{0,90},{-8,68},{8,68},{0,90}}, lineColor={192,192,192}, fillColor={192,192,192}, fillPattern=FillPattern.Solid),Text(extent={{-150,150},{150,110}}, textString="%name", lineColor={0,0,255})}), Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={Line(points={{0,80},{-8,80}}, color={95,95,95}),Line(points={{0,-80},{-8,-80}}, color={95,95,95}),Line(points={{0,-90},{0,84}}, color={95,95,95}),Text(extent={{5,104},{25,84}}, lineColor={95,95,95}, textString="y"),Polygon(points={{0,98},{-6,82},{6,82},{0,98}}, lineColor={95,95,95}, fillColor={95,95,95}, fillPattern=FillPattern.Solid)}), Documentation(revisions="<html>
<p>
Icon for a mathematical function, consisting of an y-axis in the middle.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end baseIcon2;

    annotation(Invisible=true, Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10}), graphics={Text(visible=true, origin={15.1485,69.1489}, fillPattern=FillPattern.Solid, extent={{-105.1485,-119.1489},{74.8515,-19.1489}}, textString="f(x)", fontName="Arial")}), Documentation(info="<HTML>
<p>
This package contains <b>basic mathematical functions</b> (such as sin(..)),
as well as functions operating on <b>vectors</b> and <b>matrices</b>.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
</dl>

<p>
Copyright &copy; 1998-2009, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b>
<a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">here</a>.</i>
</p><br>
</HTML>
", revisions="<html>
<ul>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Function tempInterpol2 added.</li>
<li><i>Oct. 24, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Icons for icon and diagram level introduced.</li>
<li><i>June 30, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>

</html>"));
  end Math;

  package Blocks "Library of basic input/output control blocks (continuous, discrete, logical, table blocks)"
    extends Modelica.Icons.Library;
    import SI = Modelica.SIunits;
    annotation(Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10}), graphics={Rectangle(visible=true, origin={7.5,46.0}, extent={{-32.0,-35.0},{16.0,-6.0}}),Rectangle(visible=true, origin={7.5,46.0}, extent={{-32.0,-85.0},{16.0,-56.0}}),Line(visible=true, origin={7.5,46.0}, points={{16.0,-20.0},{49.0,-20.0},{49.0,-71.0},{16.0,-71.0}}),Line(visible=true, origin={7.5,46.0}, points={{-32.0,-72.0},{-64.0,-72.0},{-64.0,-21.0},{-32.0,-21.0}}),Polygon(visible=true, origin={7.5,46.0}, fillPattern=FillPattern.Solid, points={{16.0,-71.0},{29.0,-67.0},{29.0,-74.0},{16.0,-71.0}}),Polygon(visible=true, origin={7.5,46.0}, fillPattern=FillPattern.Solid, points={{-32.0,-21.0},{-46.0,-17.0},{-46.0,-25.0},{-32.0,-21.0}})}), Documentation(info="<html>
<p>
This library contains input/output blocks to build up block diagrams.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
</dl>
<p>
Copyright &copy; 1998-2009, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b>
<a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">here</a>.</i>
</p>
</HTML>
", revisions="<html>
<ul>
<li><i>June 23, 2004</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced new block connectors and adapated all blocks to the new connectors.
       Included subpackages Continuous, Discrete, Logical, Nonlinear from
       package ModelicaAdditions.Blocks.
       Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
       and in the new package Modelica.Blocks.Tables.
       Added new blocks to Blocks.Sources and Blocks.Logical.
       </li>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       New subpackage Examples, additional components.
       </li>
<li><i>June 20, 2000</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
       Michael Tiller:<br>
       Introduced a replaceable signal type into
       Blocks.Interfaces.RealInput/RealOutput:
<pre>
   replaceable type SignalType = Real
</pre>
       in order that the type of the signal of an input/output block
       can be changed to a physical type, for example:
<pre>
   Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
</pre>
      </li>
<li><i>Sept. 18, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed to Blocks. New subpackages Math, Nonlinear.
       Additional components in subpackages Interfaces, Continuous
       and Sources. </li>
<li><i>June 30, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    package Interfaces "Library of connectors and partial models for input/output blocks"
      import Modelica.SIunits;
      extends Modelica.Icons.Library;
      connector RealInput= input Real "'input Real' as connector" annotation(defaultComponentName="u", Icon(graphics={Polygon(points={{-100,100},{100,0},{-100,-100},{-100,100}}, lineColor={0,0,127}, fillColor={0,0,127}, fillPattern=FillPattern.Solid)}, coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.2)), Diagram(coordinateSystem(preserveAspectRatio=true, initialScale=0.2, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Polygon(points={{0,50},{100,0},{0,-50},{0,50}}, lineColor={0,0,127}, fillColor={0,0,127}, fillPattern=FillPattern.Solid),Text(extent={{-10,85},{-10,60}}, lineColor={0,0,127}, textString="%name")}), Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>"));
      connector RealOutput= output Real "'output Real' as connector" annotation(defaultComponentName="y", Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Polygon(points={{-100,100},{100,0},{-100,-100},{-100,100}}, lineColor={0,0,127}, fillColor={255,255,255}, fillPattern=FillPattern.Solid)}), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Polygon(points={{-100,50},{0,0},{-100,-50},{-100,50}}, lineColor={0,0,127}, fillColor={255,255,255}, fillPattern=FillPattern.Solid),Text(extent={{30,110},{30,60}}, lineColor={0,0,127}, textString="%name")}), Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>"));
      connector BooleanInput= input Boolean "'input Boolean' as connector" annotation(defaultComponentName="u", Icon(graphics={Polygon(points={{-100,100},{100,0},{-100,-100},{-100,100}}, lineColor={255,0,255}, fillColor={255,0,255}, fillPattern=FillPattern.Solid)}, coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.2)), Diagram(coordinateSystem(preserveAspectRatio=true, initialScale=0.2, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Polygon(points={{0,50},{100,0},{0,-50},{0,50}}, lineColor={255,0,255}, fillColor={255,0,255}, fillPattern=FillPattern.Solid),Text(extent={{-10,85},{-10,60}}, lineColor={255,0,255}, textString="%name")}), Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));
      connector BooleanOutput= output Boolean "'output Boolean' as connector" annotation(defaultComponentName="y", Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Polygon(points={{-100,100},{100,0},{-100,-100},{-100,100}}, lineColor={255,0,255}, fillColor={255,255,255}, fillPattern=FillPattern.Solid)}), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}, grid={1,1}), graphics={Polygon(points={{-100,50},{0,0},{-100,-50},{-100,50}}, lineColor={255,0,255}, fillColor={255,255,255}, fillPattern=FillPattern.Solid),Text(extent={{30,110},{30,60}}, lineColor={255,0,255}, textString="%name")}), Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>"));
      annotation(Documentation(info="<HTML>
<p>
This package contains interface definitions for
<b>continuous</b> input/output blocks with Real,
Integer and Boolean signals. Furthermore, it contains
partial models for continuous and discrete blocks.
</p>

</HTML>
", revisions="<html>
<ul>
<li><i>Oct. 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Added several new interfaces. <a href=\"../Documentation/ChangeNotes1.5.html\">Detailed description</a> available.
<li><i>Oct. 24, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       RealInputSignal renamed to RealInput. RealOutputSignal renamed to
       output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
       SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
       SignalGenerator renamed to SignalSource. Introduced the following
       new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
       DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
       BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
<li><i>June 30, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>
"));
    end Interfaces;

  end Blocks;

  package SIunits "Library of type and unit definitions based on SI units according to ISO 31-1992"
    extends Modelica.Icons.Library;
    type Angle= Real(final quantity="Angle", final unit="rad", displayUnit="deg");
    type Length= Real(final quantity="Length", final unit="m");
    type Position= Length;
    type Distance= Length(min=0);
    type Area= Real(final quantity="Area", final unit="m2");
    type Acceleration= Real(final quantity="Acceleration", final unit="m/s2");
    type Mass= Real(quantity="Mass", final unit="kg", min=0);
    type Force= Real(final quantity="Force", final unit="N");
    type ElectricCurrent= Real(final quantity="ElectricCurrent", final unit="A");
    type Current= ElectricCurrent;
    type ElectricPotential= Real(final quantity="ElectricPotential", final unit="V");
    type Voltage= ElectricPotential;
    type Permeability= Real(final quantity="Permeability", final unit="H/m");
    type Resistance= Real(final quantity="Resistance", final unit="Ohm");
    annotation(Invisible=true, Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10}), graphics={Text(visible=true, origin={15.0,51.8518}, fillPattern=FillPattern.Solid, extent={{-105.0,-86.8518},{75.0,-16.8518}}, textString="[kg.m2]", fontName="Arial")}), Documentation(info="<html>
<p>This package provides predefined types, such as <i>Mass</i>,
<i>Angle</i>, <i>Time</i>, based on the international standard
on units, e.g.,
</p>

<pre>   <b>type</b> Angle = Real(<b>final</b> quantity = \"Angle\",
                     <b>final</b> unit     = \"rad\",
                     displayUnit    = \"deg\");
</pre>

<p>
as well as conversion functions from non SI-units to SI-units
and vice versa in subpackage
<a href=\"Modelica://Modelica.SIunits.Conversions\">Conversions</a>.
</p>

<p>
For an introduction how units are used in the Modelica standard library
with package SIunits, have a look at:
<a href=\"Modelica://Modelica.SIunits.UsersGuide.HowToUseSIunits\">How to use SIunits</a>.
</p>

<p>
Copyright &copy; 1998-2009, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b>
<a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">here</a>.</i>
</p>

</html>", revisions="<html>
<ul>
<li><i>Dec. 14, 2005</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Add User's Guide and removed \"min\" values for Resistance and Conductance.</li>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Added new package <b>Conversions</b>. Corrected typo <i>Wavelenght</i>.</li>
<li><i>June 6, 2000</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced the following new types<br>
       type Temperature = ThermodynamicTemperature;<br>
       types DerDensityByEnthalpy, DerDensityByPressure,
       DerDensityByTemperature, DerEnthalpyByPressure,
       DerEnergyByDensity, DerEnergyByPressure<br>
       Attribute \"final\" removed from min and max values
       in order that these values can still be changed to narrow
       the allowed range of values.<br>
       Quantity=\"Stress\" removed from type \"Stress\", in order
       that a type \"Stress\" can be connected to a type \"Pressure\".</li>
<li><i>Oct. 27, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       New types due to electrical library: Transconductance, InversePotential,
       Damping.</li>
<li><i>Sept. 18, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed from SIunit to SIunits. Subpackages expanded, i.e., the
       SIunits package, does no longer contain subpackages.</li>
<li><i>Aug 12, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Type \"Pressure\" renamed to \"AbsolutePressure\" and introduced a new
       type \"Pressure\" which does not contain a minimum of zero in order
       to allow convenient handling of relative pressure. Redefined
       BulkModulus as an alias to AbsolutePressure instead of Stress, since
       needed in hydraulics.</li>
<li><i>June 29, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Bug-fix: Double definition of \"Compressibility\" removed
       and appropriate \"extends Heat\" clause introduced in
       package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
<li><i>April 8, 1998</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Astrid Jaschinski:<br>
       Complete ISO 31 chapters realized.</li>
<li><i>Nov. 15, 1997</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.control.lth.se/~hubertus/\">Hubertus Tummescheit</a>:<br>
       Some chapters realized.</li>
</ul>
</html>"), Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={Rectangle(extent={{169,86},{349,236}}, fillColor={235,235,235}, fillPattern=FillPattern.Solid, lineColor={0,0,255}),Polygon(points={{169,236},{189,256},{369,256},{349,236},{169,236}}, fillColor={235,235,235}, fillPattern=FillPattern.Solid, lineColor={0,0,255}),Polygon(points={{369,256},{369,106},{349,86},{349,236},{369,256}}, fillColor={235,235,235}, fillPattern=FillPattern.Solid, lineColor={0,0,255}),Text(extent={{179,226},{339,196}}, lineColor={160,160,164}, textString="Library"),Text(extent={{206,173},{314,119}}, lineColor={0,0,0}, textString="[kg.m2]"),Text(extent={{163,320},{406,264}}, lineColor={255,0,0}, textString="Modelica.SIunits")}));
  end SIunits;

  package Icons "Library of icons"
    extends Modelica.Icons.Library;
    partial package Library "Icon for library"
      annotation(Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={1,1}), graphics={Rectangle(visible=true, lineColor={191,191,191}, fillColor={255,255,255}, fillPattern=FillPattern.HorizontalCylinder, lineThickness=4, extent={{-90.0,-90.0},{90.0,90.0}}, radius=25)}), Documentation(info="<html>
<p>
This icon is designed for a <b>library</b>.
</p>
</html>"));
    end Library;

    annotation(Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10}), graphics={Text(visible=true, fillPattern=FillPattern.Solid, extent={{-90.0,-35.0},{90.0,35.0}}, textString="Icons", fontName="Arial")}), Documentation(info="<html>
<p>
This package contains definitions for the graphical layout of
components which may be used in different libraries.
The icons can be utilized by inheriting them in the desired class
using \"extends\" or by directly copying the \"icon\" layer.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
</dl>

<p>
Copyright &copy; 1998-2009, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b>
<a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">here</a>.</i>
</p><br>
</HTML>
", revisions="<html>
<ul>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Added new icons <b>Function</b>, <b>Enumerations</b> and <b>Record</b>.</li>
<li><i>June 6, 2000</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Replaced <b>model</b> keyword by <b>package</b> if the main
       usage is for inheriting from a package.<br>
       New icons <b>GearIcon</b> and <b>MotorIcon</b>.</li>
<li><i>Sept. 18, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renaming package Icon to Icons.
       Model Advanced removed (icon not accepted on the Modelica meeting).
       New model Library2, which is the Library icon with enough place
       to add library specific elements in the icon. Icon also used in diagram
       level for models Info, TranslationalSensor, RotationalSensor.</li>
<li><i>July 15, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Model Caution renamed to Advanced, model Sensor renamed to
       TranslationalSensor, new model RotationalSensor.</li>
<li><i>June 30, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version.</li>
</ul>
<br>
</html>"));
  end Icons;

end Modelica;
package XogenyModels
  annotation(Icon(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})), Diagram(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})));
  package SolenoidSystem
    annotation(Icon(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})), Diagram(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})));
    model SimSysTrial "Tries to use the graphical connectors"
      import XogenyModels.Components.SolenoidSystemComponents;
      XogenyModels.Components.SolenoidSystemComponents.CarWithConnector c(x0=0, m=0.75) annotation(Placement(visible=true, transformation(origin={-37.7299,30.0}, extent={{-17.7299,-17.7299},{17.7299,17.7299}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.SolFWConnector sol1(N=1, A=1, mu=1, V=12.8, R=2, PWM=1, Px=2.0, h=1) annotation(Placement(visible=true, transformation(origin={-87.5,27.5}, extent={{-22.5,-22.5},{22.5,22.5}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.SolFWConnector sol2(N=1, A=1, mu=1, V=12.8, R=2, PWM=1, Px=4.0, h=1) annotation(Placement(visible=true, transformation(origin={-85.0,-7.7614}, extent={{-22.2386,-22.2386},{22.2386,22.2386}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.SolFWConnector sol3(N=1, A=1, mu=1, V=12.8, R=2, PWM=1, Px=6.0, h=1) annotation(Placement(visible=true, transformation(origin={-87.5,65.0}, extent={{-22.5,-22.5},{22.5,22.5}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.MagSen sensor1(Px=2) annotation(Placement(visible=true, transformation(origin={36.5252,16.5252}, extent={{-21.5252,-21.5252},{21.5252,21.5252}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.VControl control1(threshold=1) annotation(Placement(visible=true, transformation(origin={89.1647,73.8384}, extent={{-19.1647,-19.1647},{19.1647,19.1647}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.MagSen sensor2(Px=4) annotation(Placement(visible=true, transformation(origin={35.0,76.761}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.VControl control2(threshold=1) annotation(Placement(visible=true, transformation(origin={96.1694,-46.645}, extent={{-23.8306,-23.8306},{23.8306,23.8306}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.MagSen sensor3(Px=6) annotation(Placement(visible=true, transformation(origin={37.5118,-45.0}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.VControl control3(threshold=1) annotation(Placement(visible=true, transformation(origin={92.5,15.0}, extent={{-22.5,-22.5},{22.5,22.5}}, rotation=0)));
      XogenyModels.Components.SolenoidSystemComponents.TrackWC channel(m=0.75, l=4, h=1, mu=1, g=9.81, fTol=1) annotation(Placement(visible=true, transformation(origin={-84.2001,-65.7999}, extent={{-20.7999,-20.7999},{20.7999,20.7999}}, rotation=0)));
      annotation(Diagram(coordinateSystem(extent={{-148.5,-105.0},{148.5,105.0}}, preserveAspectRatio=true, initialScale=0.1, grid={5,5})));
    equation 
      connect(sensor2.V,control2.V) annotation(Line(visible=true, origin={42.4245,8.8497}, points={{4.958,68.3347},{14.9851,39.5741},{47.692,-55.1163}}, color={0,0,127}));
      connect(sensor1.V,control1.V) annotation(Line(visible=true, origin={50.3506,54.0539}, points={{-0.4986,-37.0731},{11.4816,-19.0539},{33.9462,20.0887}}, color={0,0,127}));
      connect(sensor3.V,control3.V) annotation(Line(visible=true, origin={52.7031,-1.6349}, points={{-2.8088,-42.9418},{12.2969,-19.9779},{34.0819,16.9921}}, color={0,0,127}));
      connect(sol1.command,control1.command) annotation(Line(visible=true, origin={15.1815,53.0627}, points={{-109.4315,-25.056},{-20.1815,1.9373},{54.8185,1.9373},{74.7945,21.1814}}, color={255,0,255}));
      connect(c.v,channel.v) annotation(Line(visible=true, origin={-68.1281,-28.7946}, points={{34.4325,62.3406},{-1.8719,-6.2054},{-10.2485,-19.1299},{-22.312,-37.0053}}, color={0,0,127}));
      connect(sol3.command,control3.command) annotation(Line(visible=true, origin={17.9266,35.7371}, points={{-112.1766,29.7696},{-14.1786,4.2629},{48.3254,-13.7717},{75.5259,-20.2608}}, color={255,0,255}));
      connect(sol2.command,control2.command) annotation(Line(visible=true, origin={36.0312,-26.7006}, points={{-127.7027,19.44},{33.2778,19.44},{33.2778,-19.44},{61.1471,-19.44}}, color={255,0,255}));
      connect(channel.Cf,c.c) annotation(Line(visible=true, origin={-49.8194,-31.6108}, points={{-34.3807,-34.1891},{4.8194,-34.1891},{4.8194,1.6108},{12.371,1.6108},{12.371,65.1568}}, color={0,127,0}));
      connect(sol2.sol,c.c) annotation(Line(visible=true, origin={-59.842,13.2053}, points={{-25.158,-20.3407},{1.3822,-20.3407},{1.3822,20.3407},{22.3936,20.3407}}, color={0,127,0}));
      connect(sol1.sol,c.c) annotation(Line(visible=true, origin={-60.467,30.8396}, points={{-27.033,-2.7063},{2.0072,-2.7063},{2.0072,2.7063},{23.0186,2.7063}}, color={0,127,0}));
      connect(sol3.sol,c.c) annotation(Line(visible=true, origin={-35.8521,50.0}, points={{-51.6479,15.6333},{-1.5964,15.6333},{-1.5964,-16.454},{-1.5964,-16.454}}, color={0,127,0}));
      connect(sensor3.CartMag,c.c) annotation(Line(visible=true, origin={-22.4361,-9.3111}, points={{60.0495,-35.7905},{-15.0124,-35.6889},{-15.0124,14.3111},{-15.0124,14.3111},{-15.0124,42.8571}}, color={0,127,0}));
      connect(sensor1.CartMag,c.c) annotation(Line(visible=true, origin={-8.7035,24.9809}, points={{45.338,-8.5651},{-8.2965,-8.5651},{-8.2965,8.5651},{-28.745,8.5651}}, color={0,127,0}));
      connect(sensor2.CartMag,c.c) annotation(Line(visible=true, origin={-9.0867,55.1027}, points={{44.1884,21.5567},{-7.9133,21.5567},{-7.9133,-21.5567},{-28.3617,-21.5567}}, color={0,127,0}));
    end SimSysTrial;

  end SolenoidSystem;

  package Components
    annotation(Icon(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})), Diagram(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})));
    package SolenoidSystemComponents
      import Modelica.Math;
      import Modelica.SIunits;
      import Modelica.Mechanics.Translational.Interfaces;
      annotation(Icon(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})), Diagram(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.1, grid={2,2})));
      model VControl "Controller that is based on position x"
        parameter SIunits.Voltage threshold "Threshold voltage to determine wanted proximity";
        Boolean notFinished;
        Boolean Started;
        Modelica.Blocks.Interfaces.BooleanOutput command annotation(Placement(visible=true, transformation(origin={0,0}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0), iconTransformation(origin={4.2333,2.1167}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0)));
        Modelica.Blocks.Interfaces.RealInput V annotation(Placement(visible=true, transformation(origin={-20,0}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0), iconTransformation(origin={-25.4,1.5875}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0)));
      initial equation 
        notFinished=true;
        command=false;
        Started=true;
      equation 
        when abs(abs(V) - threshold) < 0.001 and Started then
          notFinished=false;
        end when;
        when abs(V) > threshold and notFinished then
          command=true;
          Started=true;
        end when;
        annotation(Icon(graphics={Ellipse(extent={{-100,100},{100,-100}}, lineColor={0,0,0}, fillColor={0,0,0}, fillPattern=FillPattern.None),Rectangle(extent={{-25,25},{25,75}}, fillColor={255,0,0}, fillPattern=FillPattern.Solid, pattern=LinePattern.None, lineColor={0,0,0}),Rectangle(extent={{-80,5},{80,-5}}, fillColor={100,100,100}, fillPattern=FillPattern.Solid, pattern=LinePattern.None, lineColor={0,0,0}),Rectangle(extent={{-25,-25},{25,-75}}, fillColor={0,255,0}, fillPattern=FillPattern.Solid, pattern=LinePattern.None, lineColor={0,0,0}),Text(extent={{-100,-100},{100,-140}}, lineColor={0,0,255}, fillColor={85,170,255}, fillPattern=FillPattern.Solid, textString="%name")}));
      end VControl;

      model TrackWC
        parameter SIunits.Mass m "Mass of the cart";
        parameter SIunits.Length l "Length of the cart";
        parameter SIunits.Length h "Height of cart from ground";
        parameter Real mu "Coefficient of friction of the track";
        parameter SIunits.Acceleration g "Local value of g acting on cart (in vertical direction)";
        parameter Real fTol "The tolerance between switching of signs for friction";
        SIunits.Force N "Normal force from track";
        SIunits.Force W "Weight acting along track";
        SIunits.Force Ff "Frictional force from track surface";
        Modelica.Blocks.Interfaces.RealInput v annotation(Placement(visible=true, transformation(origin={-22.225,-0.5292}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0), iconTransformation(origin={-30.0,0.0}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0)));
        SIunits.Angle angle "Calculated value of the angle of the incline";
        Real tanAngle;
        Modelica.Mechanics.Translational.Interfaces.Flange_a Cf annotation(Placement(visible=true, transformation(origin={0.0,0.0}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0), iconTransformation(origin={0.0,-0.0}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0)));
      equation 
        tanAngle=h/l;
        angle=Math.atan(tanAngle);
        N=m*g*Math.cos(angle);
        if v < -fTol then
          Ff=mu*N;
        elseif v > 0 then
          Ff=-mu*N;
        else
          Ff=(-2*mu*N)/fTol*v - mu*N;
        end if;
        W=m*g*Math.sin(angle);
        Cf.f=-(W + Ff);
        annotation(Icon(graphics={Rectangle(visible=true, pattern=LinePattern.None, fillPattern=FillPattern.Solid, extent={{-100.0,-30.0},{100.0,30.0}}),Ellipse(visible=true, lineColor={255,0,0}, extent={{-20.0,-20.0},{20.0,20.0}}),Ellipse(visible=true, lineColor={255,0,0}, extent={{-15.0,-15.0},{15.0,15.0}}),Ellipse(visible=true, lineColor={255,0,0}, extent={{-10.0,-10.0},{10.0,10.0}}),Text(visible=true, lineColor={0,0,255}, fillColor={85,170,255}, fillPattern=FillPattern.Solid, extent={{-100.0,-140.0},{100.0,-100.0}}, textString="%name", fontName="Arial")}, coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10})));
      end TrackWC;

      model SolFWConnector "Model of just solenoid force (no control)"
        parameter Real N "Property of the solenoid design";
        parameter SIunits.Area A "Property of the solenoid design";
        parameter SIunits.Permeability mu "Property of the solenoid design";
        parameter SIunits.Voltage V "Voltage across solenoid";
        parameter SIunits.Resistance R "Resistance of solenoid";
        parameter Real PWM "Pulse Width Modulation of voltage across solenoid";
        parameter SIunits.Position Px "Position of solenoid";
        parameter SIunits.Distance h "Vertical air gap between car and solenoid";
        Modelica.Mechanics.Translational.Interfaces.Flange_a sol annotation(Placement(visible=true, transformation(origin={0,0}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0), iconTransformation(origin={-0.0,2.8147}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0)));
        Modelica.Blocks.Interfaces.BooleanInput command annotation(Placement(visible=true, transformation(origin={-38.2801,1.6888}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0), iconTransformation(origin={-30.0,2.2518}, extent={{-20.0,-20.0},{20.0,20.0}}, rotation=0)));
      equation 
        if command then
          sol.f=-N^2*A*mu*V^2/R^2*PWM^2*(Px - sol.s)/(h^2 + (Px - sol.s)^2)^(3/2);
        else
          sol.f=0;
        end if;
        annotation(Icon(graphics={Ellipse(extent={{-100,50},{0,-50}}, lineColor={0,0,255}, fillColor={0,0,0}, fillPattern=FillPattern.Backward),Ellipse(extent={{100,50},{0,-50}}, lineColor={0,0,255}, fillColor={0,0,0}, fillPattern=FillPattern.Forward),Rectangle(extent={{-50,50},{50,-50}}, fillColor={100,100,100}, fillPattern=FillPattern.CrossDiag, pattern=LinePattern.None)}));
      end SolFWConnector;

      model MagSen "Senses magnet on cart"
        MagProperties mag(N=1, A=1, chi=1, mu=1, h=1);
        parameter SIunits.Position Px;
        Modelica.Mechanics.Translational.Interfaces.Flange_a CartMag annotation(Placement(visible=true, transformation(origin={0,0}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0), iconTransformation(origin={0.5083,-0.5083}, extent={{-50.5083,-50.5083},{50.5083,50.5083}}, rotation=0)));
        Modelica.Blocks.Interfaces.RealOutput V annotation(Placement(visible=true, transformation(origin={61.9125,2.1167}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0), iconTransformation(origin={61.9125,2.1167}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0)));
      protected 
        SIunits.Position dx=CartMag.s - Px;
      equation 
        CartMag.f=0;
        V=-mag.N*mag.A*mag.chi*mag.mu*dx*der(CartMag.s)/(dx^2 + mag.h^2)^(3/2);
        annotation(Icon(graphics={Ellipse(visible=true, lineColor={0,0,255}, fillPattern=FillPattern.Solid, extent={{-100.0,-100.0},{100.0,100.0}}),Text(visible=true, lineColor={0,0,255}, fillColor={85,170,255}, fillPattern=FillPattern.Solid, extent={{-100.0,-140.0},{100.0,-100.0}}, textString="%name", fontName="Arial")}, coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10})));
      end MagSen;

      record MagProperties
        parameter Real N "Number of turns on solenoid";
        parameter SIunits.Area A "Area of cross section of solenoid";
        parameter SIunits.Current chi "Property of magnet";
        parameter SIunits.Permeability mu "Property of surroundings between magnet and solenoid";
        parameter SIunits.Distance h "Vertical distance between magnet and solenoid";
        annotation(Diagram(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10})));
      end MagProperties;

      model CarWithConnector
        parameter SIunits.Mass m "Mass of the car";
        parameter SIunits.Position x0 "Starting position of the car";
        SIunits.Acceleration a "Acceleration of the car";
        Modelica.Mechanics.Translational.Interfaces.Flange_a c annotation(Placement(visible=true, transformation(origin={1.5875,20.1083}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0), iconTransformation(origin={1.5875,20.0}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0)));
        Modelica.Blocks.Interfaces.RealOutput v annotation(Placement(visible=true, transformation(origin={22.7542,20.1083}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0), iconTransformation(origin={22.7542,20.0}, extent={{-10.0,-10.0},{10.0,10.0}}, rotation=0)));
      initial equation 
        c.s=x0;
      equation 
        v=der(c.s);
        a=der(v);
        c.f=m*a;
        annotation(Icon(graphics={Rectangle(visible=true, pattern=LinePattern.None, fillPattern=FillPattern.Solid, extent={{-75.0,0.0},{75.0,40.0}}),Ellipse(visible=true, fillColor={175,175,175}, fillPattern=FillPattern.Solid, extent={{-50.0,-25.0},{-25.0,0.0}}),Ellipse(visible=true, fillColor={175,175,175}, fillPattern=FillPattern.Solid, extent={{25.0,-25.0},{50.0,0.0}}),Text(visible=true, lineColor={0,0,255}, fillColor={85,170,255}, fillPattern=FillPattern.Solid, extent={{-100.0,-140.0},{100.0,-100.0}}, textString="%name", fontName="Arial")}, coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}, preserveAspectRatio=true, initialScale=0.1, grid={10,10})));
      end CarWithConnector;

    end SolenoidSystemComponents;

  end Components;

end XogenyModels;
model XogenyModels_SolenoidSystem_SimSysTrial
  extends XogenyModels.SolenoidSystem.SimSysTrial;
end XogenyModels_SolenoidSystem_SimSysTrial;
